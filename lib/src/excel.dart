@JS()
library excel;

import 'dart:async';

import 'package:angular/angular.dart';
import 'package:fixnum/fixnum.dart';
import 'package:js/js.dart';

import 'office_js.dart';
import 'proto/insertion_order_query.pb.dart';
import 'util.dart';

/// Service class that provides dart functions to interact with Excel.
@Injectable()
class ExcelDart {
  /// Underpacing table addresses.
  static const _underpacingTableAddress = 'A1:B2';
  static const _highlightOptionAddress = '\$B\$1';
  static const _thresholdAddress = '\$B\$2';

  /// `false` will be replaced in [ExcelDart.populate] with the correct value.
  /// Default threshold is set to 0.9.
  static final _underpacingTable = [
    ['highlight underpacing insertion orders', false],
    ['threshold', 0.9]
  ];

  /// Excel 'bad' preset formats.
  static const _underpacingFormatFont = '#9C0006';
  static const _underpacingFormatFill = '#FFC7CE';

  /// Result table starts at address 'A4'
  static const _resultTableColumnStartAddress = 'A';
  static const _resultTableRowStartAddress = 4;

  static const _centerAlignment = 'Center';

  static const _borderStyle = 'Continuous';
  static const _tableStyle = 'TableStyleLight9';

  static const _currencyFormat = '\$#,##0.00';
  static const _timeFormat = '12:00:00 AM';

  /// Column addresses calculated based on [_tableHeader].
  static final _currentPacingColumnAddress =
      '\$${_getExcelColumnReference(_tableHeader.indexOf(_currentPacingColumnName))}'
      '${_resultTableRowStartAddress}';
  static final _budgetUnitColumnAddress =
      '\$${_getExcelColumnReference(_tableHeader.indexOf(_budgetUnitColumnName))}'
      '${_resultTableRowStartAddress}';

  /// Table header names (spaces are not allowed).
  static const _displayNameColumnName = 'Display_Name';
  static const _advertiserIdColumnName = 'Advertiser_ID';
  static const _campaignIdColumnName = 'Campaign_ID';
  static const _insertionOrderIdColumnName = 'Insertion_Order_ID';
  static const _entityStatusColumnName = 'Entity_Status';
  static const _budgetUnitColumnName = 'Budget_Unit';
  static const _budgetColumnName = 'Budget_Amount';
  static const _spentColumnName = 'Spent_Amount';
  static const _currentPacingColumnName = 'Current_Pacing_%';
  static const _pacingPeriodColumnName = 'Pacing_Period';
  static const _pacingTypeColumnName = 'Pacing_Type';
  static const _startDateColumnName = 'Start_Date';
  static const _endDateColumnName = 'End_Date';
  static const _dailyMaxColumnName = 'Daily_Max';
  static const _dailyMaxImpressionColumnName = 'Daily_Max_Impression';
  static const _automationTypeColumnName = 'Automation_Type';
  static const _updateTimeColumnName = 'Update_Time';

  /// Header for the master table.
  ///
  /// If changes have been made to [insertion_order.proto] or
  /// the [_generateTableRow], this table header definition needs to
  /// be changed as well. The length and entries of this table header has to
  /// match with those of the table row generated by [_generateTableRow].
  static final _tableHeader = [
    _displayNameColumnName,
    _advertiserIdColumnName,
    _campaignIdColumnName,
    _insertionOrderIdColumnName,
    _entityStatusColumnName,
    _budgetUnitColumnName,
    _budgetColumnName,
    _spentColumnName,
    _currentPacingColumnName,
    _pacingPeriodColumnName,
    _pacingTypeColumnName,
    _startDateColumnName,
    _endDateColumnName,
    _dailyMaxColumnName,
    _dailyMaxImpressionColumnName,
    _automationTypeColumnName,
    _updateTimeColumnName
  ];

  /// Loads the Office JS library and returns whether the app
  /// is side-loaded in Excel
  ///
  /// Uses completer to convert call back function to future.
  Future<bool> loadOffice() {
    final completer = Completer<bool>();
    Office.onReady(
        allowInterop((info) => completer.complete(info.host == 'Excel')));
    return completer.future;
  }

  /// Waits for Office APIs to be ready and then creates
  /// a new spreadsheet with [sheetName] and populates the spreadsheet with
  /// entries in the [insertionOrderList].
  ///
  /// If user checks 'highlight underpacing insertion orders' on the UI, then
  /// [highlightUnderpacing] resolves as true, and false otherwise.
  void populate(List<InsertionOrder> insertionOrderList,
      bool highlightUnderpacing) async {
    final uniqueId = DateTime.now().millisecondsSinceEpoch;
    final sheetName = 'Query_$uniqueId';
    final tableName = 'Query_$uniqueId\_Table';

    final populateCompleter = Completer<void>();
    ExcelJS.run(allowInterop((context) {
      // Adds a new worksheet.
      final sheet = context.workbook.worksheets.add(sheetName);

      // Adds and formats the underpacing table.
      _underpacingTable[0][1] = highlightUnderpacing;
      sheet.getRange('$sheetName!$_underpacingTableAddress')
        ..format.font.bold = true
        ..values = _underpacingTable;
      sheet
          .getRange('$sheetName!$_thresholdAddress')
          .format
          .horizontalAlignment = _centerAlignment;

      // Turns [insertionOrderList] into table rows.
      final tableBody = insertionOrderList.map(_generateTableRow).toList();

      // Calculates table size and adds a master table.
      final endAddress = '${_getExcelColumnReference(_tableHeader.length - 1)}'
          '${tableBody.length + _resultTableRowStartAddress}';
      final tableAddress = '$sheetName!'
          '$_resultTableColumnStartAddress$_resultTableRowStartAddress:'
          '$endAddress';
      final table = context.workbook.tables.add(tableAddress, true);
      table
        ..name = tableName
        ..style = _tableStyle;

      // Adds and formats table header.
      table.getHeaderRowRange()
        ..values = [_tableHeader]
        ..format.font.bold = true
        ..format.horizontalAlignment = _centerAlignment
        ..format.borders.getItem('EdgeTop').style = _borderStyle
        ..format.borders.getItem('EdgeBottom').style = _borderStyle;

      // Adds and formats table body.
      table.getDataBodyRange().formulas = tableBody;

      // Formats the Daily Max column as currency.
      table.columns.getItem(_dailyMaxColumnName).getRange().numberFormat =
          _currencyFormat;

      // Center all columns except for display name column(default to left
      // align), and all columns related to numbers(default to right align).
      for (final columnName in _tableHeader) {
        if (columnName != _displayNameColumnName &&
            columnName != _budgetColumnName &&
            columnName != _spentColumnName &&
            columnName != _currentPacingColumnName &&
            columnName != _dailyMaxColumnName &&
            columnName != _dailyMaxImpressionColumnName) {
          table.columns
              .getItem(columnName)
              .getRange()
              .format
              .horizontalAlignment = _centerAlignment;
        }
      }

      // Auto-fits all used cells.
      sheet.getUsedRange().getEntireColumn().format.autofitColumns();
      sheet.getUsedRange().getEntireRow().format.autofitRows();

      // Sets the sheet as active.
      sheet.activate();

      // All operations are complete.
      return context.sync();
    })).then(allowInterop((value) {
      populateCompleter.complete();
    }));

    // Waits for population to be complete.
    await populateCompleter.future;

    // Conditionally format the budget column once the table is set.
    await _formatBudgetAndSpentColumns(tableName);

    // Highlight underpacing insertion orders if highlightUnderpacing is true.
    await _highlightUnderpacingRows(tableName);
  }

  static String _getExcelColumnReference(int offset) => String.fromCharCode(
      _resultTableColumnStartAddress.codeUnitAt(0) + offset);

  /// Conditionally formats the Budget and Spent column based on Budget Unit.
  static Future<void> _formatBudgetAndSpentColumns(String tableName) async {
    final formatCompleter = Completer<void>();
    ExcelJS.run(allowInterop((context) {
      final table = context.workbook.tables.getItem(tableName);

      final budgetRange = table.columns.getItem(_budgetColumnName).getRange();
      final spentRange = table.columns.getItem(_spentColumnName).getRange();

      final budgetFormat = budgetRange.conditionalFormats.add('Custom');
      final spentFormat = spentRange.conditionalFormats.add('Custom');

      final formula = '$_budgetUnitColumnAddress = '
          '"${InsertionOrder_Budget_BudgetUnit.BUDGET_UNIT_CURRENCY}"';

      budgetFormat.custom.rule.formula = formula;
      spentFormat.custom.rule.formula = formula;

      budgetFormat.custom.format.numberFormat = _currencyFormat;
      spentFormat.custom.format.numberFormat = _currencyFormat;

      // All operations are complete.
      return context.sync();
    })).then(allowInterop((value) {
      formatCompleter.complete();
    }));

    return formatCompleter.future;
  }

  /// Highlight rows that are underpacing.
  ///
  /// Structured reference (i.e. Table[@Column]) is not allowed in Excel
  /// conditional formatting. Regular reference (i.e. $O5 or what
  /// [_currentPacingColumnAddress] evaluates to) has to be used
  /// instead. As table expands, Excel will automatically extends the
  /// conditional formatting rule to cover the entire range.
  static Future<void> _highlightUnderpacingRows(String tableName) async {
    final formatCompleter = Completer<void>();
    ExcelJS.run(allowInterop((context) {
      final table = context.workbook.tables.getItem(tableName);
      final range = table.getDataBodyRange();
      final format = range.conditionalFormats.add('Custom');

      format.custom.rule.formula = 'AND($_highlightOptionAddress=TRUE,'
          '$_currentPacingColumnAddress < $_thresholdAddress)';

      format.custom.format.fill.color = _underpacingFormatFill;
      format.custom.format.font.color = _underpacingFormatFont;

      // All operations are complete.
      return context.sync();
    })).then(allowInterop((value) {
      formatCompleter.complete();
    }));

    return formatCompleter.future;
  }

  /// Generates a row from [insertionOrder] by creating fields that matches
  /// those specified in [_tableHeader].
  static List<String> _generateTableRow(InsertionOrder insertionOrder) {
    return [
      insertionOrder.displayName,
      insertionOrder.advertiserId,
      insertionOrder.campaignId,
      insertionOrder.insertionOrderId,
      insertionOrder.entityStatus.toString(),
      insertionOrder.budget.budgetUnit.toString(),
      _calculateActiveBudgetAmount(insertionOrder.budget.budgetUnit,
          insertionOrder.budget.activeBudgetSegment.budgetAmountMicros),
      insertionOrder.spent,
      _calculateCurrentPacingPercentage(),
      insertionOrder.pacing.pacingPeriod.toString(),
      insertionOrder.pacing.pacingType.toString(),
      _calculateDate(
          insertionOrder.budget.activeBudgetSegment.dateRange.startDate),
      _calculateDate(
          insertionOrder.budget.activeBudgetSegment.dateRange.endDate),
      _calculatePacingDailyMax(insertionOrder.pacing.dailyMaxMicros),
      insertionOrder.pacing.dailyMaxImpressions,
      insertionOrder.budget.automationType.toString(),
      insertionOrder.updateTime,
    ];
  }

  /// Calculates pacing daily max in standard unit.
  static String _calculatePacingDailyMax(String dailyMaxMicros) =>
      dailyMaxMicros.isEmpty
          ? dailyMaxMicros
          : Util.convertMicrosToStandardUnitString(
              Int64.parseInt(dailyMaxMicros));

  static String _calculateActiveBudgetAmount(
          InsertionOrder_Budget_BudgetUnit budgetUnit,
          String budgetAmountMicros) =>
      budgetUnit == InsertionOrder_Budget_BudgetUnit.BUDGET_UNIT_CURRENCY
          ? Util.convertMicrosToStandardUnitString(
              Int64.parseInt(budgetAmountMicros))
          : budgetAmountMicros;

  /// Uses Excel built-in formula to calculate current pacing percentage.
  ///
  /// The formula calculates:
  /// (spent / budget) / (current duration / flight duration)
  /// where duration has granularity of hours. And if current duration is less
  /// than 1 day or 10% of the total flight duration, it will show
  /// 'not_enough_information".
  static String _calculateCurrentPacingPercentage() {
    // (dateA - dateB) returns the difference between two dates in days,
    // and with fractions showing the difference between times in seconds.
    //
    // MROUND(dateA - dateB, 1/24) rounds the difference to hours.
    //
    // Only inflight IOs are displayed in the table, so current duration will
    // not have negative values.
    // And the final pacing percentage is rounded to two decimal places.
    final formula = '''
    =IF(AND(
        NOW() - [$_startDateColumnName] > 1,
        MROUND(NOW() - [$_startDateColumnName], 1/24) > 
               0.1 * ([$_endDateColumnName] - [$_endDateColumnName])),

        ROUND(
        ([$_spentColumnName] / [$_budgetColumnName]) /
        (
          MROUND(NOW() - [$_startDateColumnName], 1/24) / 
          ([$_endDateColumnName] - [$_startDateColumnName])
        ), 2),

        "not_enough_information"
        )
    ''';

    return formula.replaceAll(RegExp(r'\s+'), '');
  }

  /// Converts proto [Date] into Excel date time format.
  static String _calculateDate(
          InsertionOrder_Budget_BudgetSegment_DateRange_Date date) =>
      '${date.month}/${date.day}/${date.year} $_timeFormat';
}

/// Below are wrapper functions for Office Excel APIs.
/// The Type definitions can be found at
/// https://docs.microsoft.com/en-us/javascript/api/excel?view=excel-js-preview.

/// Top level JS class Excel.
///
/// ``` js
///   Excel.run()
/// ```
@JS('Excel')
class ExcelJS {
  /// Executes a batch script that performs actions
  /// on the Excel object model using a new RequestContext.
  external static JsPromise run(JsPromise Function(RequestContext) callback);
}

/// Wrapper for Excel.RequestContext class.
///
/// ``` js
///   Excel.RequestContext.workbook
///   Excel.RequestContext.sync()
/// ```
@JS()
class RequestContext {
  /// The current workbook.
  external WorkBook get workbook;

  /// Synchronizes the state between
  /// JavaScript proxy objects and the Office document.
  external JsPromise sync();
}

/// Wrapper class for javascript Promise class.
///
/// ``` js
///   Promise.then()
/// ```
@JS()
class JsPromise {
  external JsPromise then(dynamic Function(dynamic value) fulfilled,
      [dynamic Function(dynamic reason) rejected]);
}

/// Wrapper for Excel.WorkBook class.
///
/// ``` js
///   Excel.WorkBook.name
///   Excel.WorkBook.worksheets
///   Excel.WorkBook.getSelectedRange()
/// ```
@JS()
class WorkBook {
  /// The name of the workbook.
  external String get name;

  /// The collection of worksheets in the workbook.
  external WorksheetCollection get worksheets;

  /// The collection of tables associated with the workbook.
  external TableCollection get tables;

  /// Returns the currently selected one or more ranges from the workbook.
  external Range getSelectedRange();
}

/// Wrapper for Excel.WorksheetCollection class.
///
/// ``` js
///   Excel.WorksheetCollection.getActiveWorksheet()
/// ```
@JS()
class WorksheetCollection {
  /// Returns the currently active worksheet in the workbook.
  external Worksheet getActiveWorksheet();

  /// Adds a new worksheet to the workbook.
  external Worksheet add(String name);
}

/// Wrapper for Excel.TableCollection class.
///
/// ``` js
///   Excel.TableCollection.add()
///   Excel.TableCollection.getItem()
/// ```
@JS()
class TableCollection {
  /// Adds a new table to the workbook.
  external Table add(String address, bool hasHeader);

  /// Gets a table by Name or ID.
  external Table getItem(String key);
}

/// Wrapper for Excel.Worksheet class.
///
/// ``` js
///   Excel.Worksheet.getRange()
///   Excel.Worksheet.activate()
///   Excel.Worksheet.getUsedRange()
/// ```
@JS()
class Worksheet {
  /// Returns the range object, representing a single rectangular
  /// block of cells, specified by the address.
  external Range getRange(String address);

  /// Activates the worksheet in the Excel UI.
  external void activate();

  /// The smallest range that encompasses any cells that
  /// have a value or formatting assigned to them.
  external Range getUsedRange();
}

/// Wrapper for Excel.Table class.
///
/// ``` js
///   Excel.Table.name
///   Excel.Table.columns
///   Excel.Table.getHeaderRowRange()
///   Excel.Table.getDataBodyRange()
/// ```
@JS()
class Table {
  /// Name of the table.
  external set name(String name);

  /// Excel preset table styles.
  /// Possible values are: "TableStyleLight1" through "TableStyleLight21",
  /// "TableStyleMedium1" through "TableStyleMedium28",
  /// "TableStyleDark1" through "TableStyleDark11".
  external set style(String style);

  /// Represents a collection of all the columns in the table.
  external TableColumnCollection get columns;

  /// Gets the range object associated with header row of the table.
  external Range getHeaderRowRange();

  /// Gets the range object associated with the data body of the table.
  external Range getDataBodyRange();
}

/// Wrapper for Excel.TableColumnCollection class.
///
/// ``` js
///   Excel.TableColumnCollection.getItem
/// ```
@JS()
class TableColumnCollection {
  /// Gets a column object by Name or ID
  external TableColumn getItem(String key);
}

/// Wrapper for Excel.TableColumnCollection class.
///
/// ``` js
///   Excel.TableColumnCollection.getRange()
/// ```
@JS()
class TableColumn {
  /// Gets the range object associated with the entire column.
  external Range getRange();
}

/// Wrapper for Excel.Range class.
///
/// ``` js
///   Excel.Range.format
///   Excel.Range.values
///   Excel.Range.getEntireColumn()
///   Excel.Range.getEntireRow()
/// ```
@JS()
class Range {
  /// The RangeFormat object, encapsulating the range's font, fill, borders,
  /// alignment, and other properties.
  external RangeFormat get format;

  /// Represents a collection of all the conditional formats that
  /// are overlap the range.
  external ConditionalFormatCollection get conditionalFormats;

  /// The raw values of the specified range.
  external set values(dynamic v);

  /// Gets an object that represents the entire column of the range.
  external Range getEntireColumn();

  /// Gets an object that represents the entire row of the range.
  external Range getEntireRow();

  /// Represents the formula in A1-style notation.
  external set formulas(dynamic formulas);

  /// Represents Excel's number format code for the given range.
  external set numberFormat(String format);
}

/// Wrapper for Excel.RangeFormat class.
///
/// ``` js
///   Excel.RangeFormat.autofitColumns()
///   Excel.RangeFormat.autofitRows()
///   Excel.RangeFormat.font
///   Excel.RangeFormat.borders
/// ```
@JS()
class RangeFormat {
  /// Changes the width of the columns of the current range to
  /// achieve the best fit.
  external void autofitColumns();

  /// Changes the height of the rows of the current range to
  /// achieve the best fit.
  external void autofitRows();

  /// Returns the font object defined on the overall range.
  external RangeFont get font;

  /// Collection of border objects that apply to the overall range.
  external RangeBorderCollection get borders;

  /// Represents the horizontal alignment for the specified object.
  /// Valid values are:  "General", "Left", "Center", "Right", "Fill"
  /// "Justify", "CenterAcrossSelection", "Distributed".
  external set horizontalAlignment(String alignment);
}

/// Wrapper for Excel.ConditionalFormatCollection class.
///
/// ``` js
///   Excel.ConditionalFormatCollection.add()
/// ```
@JS()
class ConditionalFormatCollection {
  /// Adds a new conditional format to the collection.
  /// Valid values are: "Custom", "DataBar", "ColorScale", "IconSet",
  /// "TopBottom", "PresetCriteria", "ContainsText", "CellValue".
  external ConditionalFormat add(String format);
}

/// Wrapper for Excel.ConditionalFormat class.
///
/// ``` js
///   Excel.ConditionalFormat.custom
/// ```
@JS()
class ConditionalFormat {
  /// The custom conditional format properties if the current
  /// conditional format is a custom type.
  external CustomConditionalFormat get custom;
}

/// Wrapper for Excel.TextConditionalFormat class.
///
/// ``` js
///   Excel.TextConditionalFormat.format
///   Excel.TextConditionalFormat.rule
/// ```
@JS()
class CustomConditionalFormat {
  /// The conditional formats font, fill, borders, and other properties.
  external ConditionalRangeFormat get format;

  /// The Rule object on this conditional format.
  external ConditionalFormatRule get rule;
}

/// Wrapper for Excel.ConditionalRangeFormat class.
///
/// ``` js
///   Excel.ConditionalRangeFormat.numberFormat
/// ```
@JS()
class ConditionalRangeFormat {
  /// Conditional format font.
  external ConditionalRangeFont get font;

  /// Conditional format Fill.
  external ConditionalRangeFill get fill;

  /// Represents Excel's number format code for the given range.
  external set numberFormat(String format);
}

/// Wrapper for Excel.ConditionalRangeFont class.
///
/// ``` js
///   Excel.ConditionalRangeFont.color
/// ``` js
class ConditionalRangeFont {
  /// Font color.
  external set color(String color);
}

/// Wrapper for Excel.ConditionalRangeFill class.
///
/// ``` js
///   Excel.ConditionalRangeFill.color
/// ``` js
class ConditionalRangeFill {
  /// Fill color.
  external set color(String color);
}

/// Wrapper for Excel.ConditionalFormatRule class.
///
/// ``` js
///   Excel.ConditionalFormatRule.formula
/// ```
@JS()
class ConditionalFormatRule {
  /// Set the conditional format rule on in R1C1-style notation.
  external set formula(String formula);
}

/// Wrapper for Excel.RangeFont class.
///
/// ``` js
///   Excel.RangeFont.name
///   Excel.RangeFont.size
///   Excel.RangeFont.color
///   Excel.RangeFont.bold
/// ```
@JS()
class RangeFont {
  /// Font name (e.g., "Calibri").
  external set name(String name);

  /// Font size.
  external set size(int size);

  /// HTML color code representation of the text color
  /// (e.g., #FF0000 represents Red).
  external set color(String color);

  /// Specifies the bold status of font.
  external set bold(bool bold);
}

/// Wrapper for Excel.RangeBorderCollection class.
///
/// ``` js
///   Excel.RangeBorderCollection.getItem()
/// ```
@JS()
class RangeBorderCollection {
  /// Gets a border object using its name.
  /// Valid values are: "EdgeTop", "EdgeBottom", "EdgeLeft", "EdgeRight",
  /// "InsideVertical", "InsideHorizontal", "DiagonalDown", "DiagonalUp".
  external RangeBorder getItem(String value);
}

/// Wrapper for Excel.RangeBorder class.
///
/// ``` js
///   Excel.RangeBorder.style
/// ```
@JS()
class RangeBorder {
  /// Specifies the line style for the border.
  /// Valid values are: "None", "Continuous", "Dash", "DashDot", "DashDotDot",
  /// "Dot", "Double", "SlantDashDot"
  external set style(String style);
}
